// Инструмент для поиска, обработки и замены текста (найди мне что-то в таком-то формате)
// Это лучше простого поиска тем, что позволяет задать шаблон


// -----------------------------------------------------  1 Объявление

// 1) Через слэш - статический способ
const regExp1 = /love/gmi
//  /love/ - паттерн
//  gmi - флаги

// 2) Через конструктор.
const regExp2 = new RegExp('love', 'gmi')
// 'love' = паттерн
// 'gmi' - флаг

// более гибкий вариант, тк можно добавить динамическую переменную
const peremennaya = 'you'
const regExp3 = new RegExp(`love ${peremennaya}`, 'gmi')

// пример
function checkSubstr(str, substr) { //содержится ли substr в str? true/false
    const regExp = new RegExp(substr)
    return regExp.test(str)
}

console.log(checkSubstr('I love you', 'love')); //true


// -----------------------------------------------------  2 Флаги
// i , g , m

// ----------------------     i     -----------------------
// поисковое выражение внутри нечувствительно к регистру

console.log(/love/i.test('I love you')); //есть ли love в 'I love you'? //true
console.log(/LOVE/i.test('I love you')); //есть ли love в 'I love you'? //true

console.log(/LOVE/.test('I love you')); //есть ли love в 'I love you'? //false, т.к. убрали i

// ----------------------     g     -----------------------
// глобальный поиск - находим все вхождения

console.log('I love you'.match(/love/g)); //[ 'love' ]
console.log('I love love you'.match(/love/g)); //[ 'love', 'love' ]

//без g - получаем только первое вхождение
console.log('I love love you'.match(/love/)); //[ 'love', index: 2, input: 'I love love you', groups: undefined ]


// ----------------------     m     -----------------------
// мультистрочный поиск

const str = `1 котенок
2 котенок
3 котенок`

console.log(str.match(/^\d/gm)) //[ '1', '2', '3' ]
//без m
console.log(str.match(/^\d/g)) //[ '1', '2', '3' ] //[ '1' ] - только то что на первой строке

// -----------------------------------------------------  3 Методы

// ----------------------     match     -----------------------

// str.match(regExp)

// используется для поиска совпадений с регулярным выражением в строке
// возвращает массив, содержащий все совпадения, или null, если совпадений не найдено

// с доп свойствами
console.log('I love you'.match(/love/)); //[ 'love', index: 2, input: 'I love you', groups: undefined ]

// чтобы возвращал только совпадение - добавим g
console.log('I love you'.match(/love/g)); //[ 'love' ]

//если совпадений нет
console.log('I love you'.match(/like/g)); //  null

//чтобы возвращает не null, а пустой массив
const mySearch = 'I love you'.match(/like/g) || []
console.log(mySearch);  // []

// ----------------------     replace     -----------------------

// str.replace(regexp, newSubstr)

//   используется для замены части строки, которая соответствует регулярному выражению
//   или подстроке, на новую подстроку.
//   этот метод возвращает новую строку, где сделаны все замены.


// заменим love на like
console.log('I love you'.replace(/love/, 'like')); // I like you


// ----------------------     test     -----------------------

// regexp.test(str)

//   используется для проверки, соответствует ли строка регулярному выражению.
//   Он возвращает true, если есть хотя бы одно совпадение, и false, если совпадений нет.

console.log(/love/.test('I love you')); //true

// -----------------------------------------------------  4 Буквенные классы

//  \d - любая цифра
//  \w - любая латинская буква, цифра, _
//  \s - пробел

//  \D - все символы кроме цифр
//  \W - все символы кроме \w (кроме любой латинской буквы, цифры, _)
//  \S - все символы кроме пробела

//    . - любой символ кроме \n

console.log(
    /\d\d/.test('22 jan')   // выдаст true - т.к. есть 2 цифры подряд
)
console.log(
    /\d\d\d/.test('22 jan')   // выдаст false - т.к. нет 3 цифры подряд
)
console.log(
    /\d/.test('22 jan')   // выдаст true - т.к. есть хоть одна цифра
)

//    \b - граница слова
// хочу найти все вхождения слова Java (не JavaScript)
console.log(
    /\bJava\b/i.test('JavaScript') // false
)
console.log(
    /\bJava\b/i.test('JavaScript')   // true
)

// -----------------------------------------------------  5 Якоря

//  ^ - начало строки
//  $ - конец строки

console.log(
    /^\d\d/.test('22 jan')   // true, тк тут написано - строка должна начинаться из двух цифер
)
console.log(
    /^\d\d$/.test('22 jan')   // false, тк тут написано - строка должна состоять только из двух цифер
)

// -----------------------------------------------------  6 Пропуск специальных символов
// специальные символы  [ \ ^ $ ( ) . | ? * + /
//   перед символом ставим \

console.log(
    /\^\$\./.test('^$.')   // true
)
console.log(
    /\^$\./.test('^$.')   // false
)

// но! если используем new RegExp, то используем два слэша \\
const myreg = new RegExp ('\\^\\$\\.')
console.log(myreg.test('^$.'))  // true

// -----------------------------------------------------  7 Наборы и диапазоны
//  [  набор символов  ] - любой набор символов из скобок
//  [0-9] - различные диапазоны цифр
//  [A-Z] - различные диапазоны букв, можно включать кириллицу
//  [0-9A-Za-z] - различное перечисление диапазонов

// можно добавлять исключения [^A-Z] - любой символ кроме A-Z
// можно добавлять \s \d, все работает  [\s\d] - любой символ кроме A-Z

// ИСКЛЮЧЕНИЯ
// Без экранирования можно писать:
//  1   . + ()
//  2   -  (+-/) - воспринимается как диапазон между символами по бокам
//  3   ^
//  4   ]

console.log(
    /[sdf]/.test('ggg')   // false
)
console.log(
    /[sdf]/.test('gggs')   // true, тк есть совпадение хотя бы по одной букве
)
console.log(
    /[0-9A-Za-z]/.test('gggsя')   // true, тк есть совпадение хотя бы по одной букве, по одному символу
)

// -----------------------------------------------------  8 Квантификаторы
// {n} - точное количество
// [a-z]{3}
// {n1, n2} - точное количество от n1 до n2
// {n1, } - точное количество от n1 и хоть до бесконечности. т.е. точная граница

console.log(
    /\d{3}/.test('123') // true, т.к. 3 цифры
)
console.log(
    /\d{3}/.test('12') // false, т.к. меньше 3 цифр
)

// -----------------------------------------------------  8.1 Сокращение квантификаторов
//   +   это {1, } от 1 до бесконечности
//   ?   это {0,1} существует это выражение или нет
//   *   это {0,} от 0 и выше

console.log(
    /\d+/.test('12') // true, т.к. больше 1 циферки
)

// -----------------------------------------------------  9 Жадность и лень
// Жадность и лень — это два противоположных подхода к поиску совпадений в регулярных выражениях.
// Они влияют на то, сколько символов будет охвачено при применении к строке.

// Жадность (Greedy)
// Жадные квантификаторы стараются захватить как можно больше символов. Они делают всё, чтобы найти максимально возможное совпадение. Например:
//
// .* — жадный квантификатор, который соответствует любому количеству символов (включая ноль). Он постарается захватить как можно больше символов.
//
//     Пример:
//
// Для строки "abc123xyz" регулярное выражение a.*z совпадет с "abc123xyz", захватив всё между первым a и последним z.

// Лень (Lazy)
// Ленивые квантификаторы (или "неспешные") ищут минимальное количество символов, которое удовлетворяет выражению. Они будут искать только первое возможное совпадение, а не растягивать его на всё, что возможно.
//
//     .*? — ленивый квантификатор, который захватывает минимальное количество символов. Он будет искать совпадение как можно быстрее.
//
//     Пример:
//
// Для строки "abc123xyz" регулярное выражение a.*?z совпадет только с "abc123z", захватив символы между первым a и первым z.

// Пример в контексте:
//     Жадность: a.*z
//
// Строка: "abczxyz"
//
// Совпадение: "abczxyz" (захватывает всё между первым a и последним z)
//
// Лень: a.*?z
//
//     Строка: "abczxyz"
//
// Совпадение: "abcz" (захватывает только до первого z)
//
// Итак: если вам нужно, чтобы регулярное выражение не охватывало лишнего, используйте ленивые квантификаторы. Если же вам нужно захватить как можно больше, выберите жадные.